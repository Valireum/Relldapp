module;
import m: main;



function f_airdrop(t_amount: decimal, symbol: text){
	
		val c = m.token@{.symbol == symbol};
		for (u in m.user@*{}) {
			create m.balance(u, c, .amount = t_amount);
	
	}
	
}

function f_create_user_balance(u: m.user) {
	for (c in m.token@*{}) {
		create m.balance(u, c, .amount = 150.0);
	}
}

function f_update_balance(user: pubkey, token:text, t_amount:decimal, inout:boolean) {
	require( t_amount > 0, "Amount is too low" );
	if (inout) {
		update m.balance@{.user.pubkey == user, .token.symbol == token}(.amount += t_amount);
	} else {
		require( m.balance@{.user.pubkey == user, .token.symbol == token}.amount >= t_amount, "balance is too low" );
		update m.balance@{.user.pubkey == user, .token.symbol == token}(.amount -= t_amount);
	}
}

function f_handle_exp(exp:integer, n:name){
	val cuser = m.user_stats@{.user.name == n};
	cuser.exp_points += exp;
	val target = cuser.level * 500;
	if (cuser.exp_points > target){
		cuser.level += 1;
		cuser.exp_points = cuser.exp_points % 500;
		if (cuser.exp_points > cuser.level * 500){
			f_handle_exp(cuser.exp_points, n);
		}
	}
	update m.user_stats@{.user.name == n}(.level = cuser.level, .exp_points = cuser.exp_points);
	update m.user_stats@{.user.name == n}(.skill_points = abs(cuser.level / 5));
	
}


//start Random 

object random_pool { mutable state: byte_array = chain_context.blockchain_rid; }

object random_obj {
 mutable last_rand :decimal = 0.0;
 mutable rand_num : decimal = 0.0;
}

function get_next_random_byte() : byte_array {
 val new_state = (random_pool.state, 
                  op_context.transaction.tx_hash, // current transaction
                     block @ { .block_height == op_context.block_height - 1} .block_rid // last block rid
                     ).hash(); // mix all data together
    random_pool.state = new_state;
    return new_state;
}

function get_next_random_decimal(): decimal {
    val hex = get_next_random_byte().to_hex();
    // pick the last 8 digits (4 bytes)
    val octet = hex.sub(hex.size()-8);
    val seed = integer.from_hex(octet);
    while (random_obj.last_rand == random_obj.rand_num) {
     random_obj.rand_num = (seed * 
           3.141592653589793 // PI number
             ) % 1;
    }
    random_obj.last_rand = random_obj.rand_num;
    return random_obj.last_rand;
   
}

function random_int(low : integer, high: integer) : integer {
 return integer((get_next_random_decimal() * (high - low + 1) + low));
}

// shuffle-algorithm
function shuffle(array: list<integer>) {
 var i = array.size() - 1;
 while (i > 0) {
  val j = random_int(0, i);
  
  // swap
  val temp = array[i];
  array[i] = array[j];
  array[j] = temp;
  
  i--;
 }
}

//end Random


function f_fill_order(buy:m.ex_live, sell:m.ex_live, date:timestamp) {
	val orderpair = buy.ex_order.token_pairs;
	val sell_amount = sell.ex_order.amount - sell.filled;
	val buy_amount = buy.ex_order.amount - buy.filled;
	
	var amount_to_fill = 0.0;

	if (sell_amount >= buy_amount) {
		amount_to_fill = buy_amount;
	}
	else {
		amount_to_fill = sell_amount;
	}
	
	update m.ex_live@{.id == buy.id}(.filled += amount_to_fill);
	update m.ex_live@{.id == sell.id}(.filled += amount_to_fill);
	
	update m.balance@{.user == buy.ex_order.maker, .token == orderpair.second }(.amount =+ amount_to_fill);
	update m.balance@{.user == sell.ex_order.maker, .token == orderpair.main }(.amount =+ (amount_to_fill*sell.ex_order.price));
	
	val Id = (m.ex_live_transactions@*{}).size();
	create m.ex_live_transactions(id = Id, buy_order = buy, sell_order = sell, token_pairs = orderpair, amount = amount_to_fill, date);
	
}

//order matcher

function f_match_orders(order:m.ex_order, date:timestamp) {
	val Id = (m.ex_live@*{}).size();
	
	var newliveorder = create m.ex_live(Id, order, 0.0);
	if (order.order_type == m.order_type.value(0)) {
		val orderlists = m.ex_live@*{.canceled == false, .ex_order.token_pairs == newliveorder.ex_order.token_pairs, .ex_order.order_type.value == 1, .filled < .ex_order.amount and .ex_order.price <= order.price}(.id, @sort .ex_order.price);
		for (liveorder in orderlists) {
			val sell_order = m.ex_live@{.id == liveorder.id};
			f_fill_order(newliveorder, sell_order, date);
			if(newliveorder.filled == newliveorder.ex_order.amount){break;}
			
		}
	}else {
		val orderlists = m.ex_live@*{.canceled == false, .ex_order.token_pairs == newliveorder.ex_order.token_pairs, .ex_order.order_type.value == 0, .filled < .ex_order.amount and .ex_order.price >= order.price}(.id, @sort_desc .ex_order.price);
		for (liveorder in orderlists) {
			val buy_order = m.ex_live@{.id == liveorder.id};
			f_fill_order(buy_order, newliveorder, date);
			if(newliveorder.filled == newliveorder.ex_order.amount){break;}
			
		}
	}
	
	
}


